// Code generated by protoc-gen-go. DO NOT EDIT.
// source: evented.proto

package evented

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	any "github.com/golang/protobuf/ptypes/any"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type Events struct {
	Events               []*Event `protobuf:"bytes,1,rep,name=events,proto3" json:"events,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Events) Reset()         { *m = Events{} }
func (m *Events) String() string { return proto.CompactTextString(m) }
func (*Events) ProtoMessage()    {}
func (*Events) Descriptor() ([]byte, []int) {
	return fileDescriptor_a2bc67ef66fabb2c, []int{0}
}

func (m *Events) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Events.Unmarshal(m, b)
}
func (m *Events) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Events.Marshal(b, m, deterministic)
}
func (m *Events) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Events.Merge(m, src)
}
func (m *Events) XXX_Size() int {
	return xxx_messageInfo_Events.Size(m)
}
func (m *Events) XXX_DiscardUnknown() {
	xxx_messageInfo_Events.DiscardUnknown(m)
}

var xxx_messageInfo_Events proto.InternalMessageInfo

func (m *Events) GetEvents() []*Event {
	if m != nil {
		return m.Events
	}
	return nil
}

type Event struct {
	Id                   string           `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	User                 string           `protobuf:"bytes,2,opt,name=user,proto3" json:"user,omitempty"`
	Ts                   string           `protobuf:"bytes,3,opt,name=ts,proto3" json:"ts,omitempty"`
	Bodies               []*EventSequence `protobuf:"bytes,8,rep,name=bodies,proto3" json:"bodies,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *Event) Reset()         { *m = Event{} }
func (m *Event) String() string { return proto.CompactTextString(m) }
func (*Event) ProtoMessage()    {}
func (*Event) Descriptor() ([]byte, []int) {
	return fileDescriptor_a2bc67ef66fabb2c, []int{1}
}

func (m *Event) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Event.Unmarshal(m, b)
}
func (m *Event) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Event.Marshal(b, m, deterministic)
}
func (m *Event) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Event.Merge(m, src)
}
func (m *Event) XXX_Size() int {
	return xxx_messageInfo_Event.Size(m)
}
func (m *Event) XXX_DiscardUnknown() {
	xxx_messageInfo_Event.DiscardUnknown(m)
}

var xxx_messageInfo_Event proto.InternalMessageInfo

func (m *Event) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Event) GetUser() string {
	if m != nil {
		return m.User
	}
	return ""
}

func (m *Event) GetTs() string {
	if m != nil {
		return m.Ts
	}
	return ""
}

func (m *Event) GetBodies() []*EventSequence {
	if m != nil {
		return m.Bodies
	}
	return nil
}

type EventSequence struct {
	Sequence             uint32   `protobuf:"varint,1,opt,name=sequence,proto3" json:"sequence,omitempty"`
	EventDetails         *any.Any `protobuf:"bytes,2,opt,name=eventDetails,proto3" json:"eventDetails,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EventSequence) Reset()         { *m = EventSequence{} }
func (m *EventSequence) String() string { return proto.CompactTextString(m) }
func (*EventSequence) ProtoMessage()    {}
func (*EventSequence) Descriptor() ([]byte, []int) {
	return fileDescriptor_a2bc67ef66fabb2c, []int{2}
}

func (m *EventSequence) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_EventSequence.Unmarshal(m, b)
}
func (m *EventSequence) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_EventSequence.Marshal(b, m, deterministic)
}
func (m *EventSequence) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventSequence.Merge(m, src)
}
func (m *EventSequence) XXX_Size() int {
	return xxx_messageInfo_EventSequence.Size(m)
}
func (m *EventSequence) XXX_DiscardUnknown() {
	xxx_messageInfo_EventSequence.DiscardUnknown(m)
}

var xxx_messageInfo_EventSequence proto.InternalMessageInfo

func (m *EventSequence) GetSequence() uint32 {
	if m != nil {
		return m.Sequence
	}
	return 0
}

func (m *EventSequence) GetEventDetails() *any.Any {
	if m != nil {
		return m.EventDetails
	}
	return nil
}

type Snapshot struct {
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Sequence             uint32   `protobuf:"varint,2,opt,name=sequence,proto3" json:"sequence,omitempty"`
	Ts                   string   `protobuf:"bytes,3,opt,name=ts,proto3" json:"ts,omitempty"`
	SnapshotDetails      *any.Any `protobuf:"bytes,4,opt,name=snapshotDetails,proto3" json:"snapshotDetails,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Snapshot) Reset()         { *m = Snapshot{} }
func (m *Snapshot) String() string { return proto.CompactTextString(m) }
func (*Snapshot) ProtoMessage()    {}
func (*Snapshot) Descriptor() ([]byte, []int) {
	return fileDescriptor_a2bc67ef66fabb2c, []int{3}
}

func (m *Snapshot) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Snapshot.Unmarshal(m, b)
}
func (m *Snapshot) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Snapshot.Marshal(b, m, deterministic)
}
func (m *Snapshot) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Snapshot.Merge(m, src)
}
func (m *Snapshot) XXX_Size() int {
	return xxx_messageInfo_Snapshot.Size(m)
}
func (m *Snapshot) XXX_DiscardUnknown() {
	xxx_messageInfo_Snapshot.DiscardUnknown(m)
}

var xxx_messageInfo_Snapshot proto.InternalMessageInfo

func (m *Snapshot) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Snapshot) GetSequence() uint32 {
	if m != nil {
		return m.Sequence
	}
	return 0
}

func (m *Snapshot) GetTs() string {
	if m != nil {
		return m.Ts
	}
	return ""
}

func (m *Snapshot) GetSnapshotDetails() *any.Any {
	if m != nil {
		return m.SnapshotDetails
	}
	return nil
}

type Command struct {
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	User                 string   `protobuf:"bytes,2,opt,name=user,proto3" json:"user,omitempty"`
	CommandSpecifics     *any.Any `protobuf:"bytes,8,opt,name=commandSpecifics,proto3" json:"commandSpecifics,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Command) Reset()         { *m = Command{} }
func (m *Command) String() string { return proto.CompactTextString(m) }
func (*Command) ProtoMessage()    {}
func (*Command) Descriptor() ([]byte, []int) {
	return fileDescriptor_a2bc67ef66fabb2c, []int{4}
}

func (m *Command) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Command.Unmarshal(m, b)
}
func (m *Command) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Command.Marshal(b, m, deterministic)
}
func (m *Command) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Command.Merge(m, src)
}
func (m *Command) XXX_Size() int {
	return xxx_messageInfo_Command.Size(m)
}
func (m *Command) XXX_DiscardUnknown() {
	xxx_messageInfo_Command.DiscardUnknown(m)
}

var xxx_messageInfo_Command proto.InternalMessageInfo

func (m *Command) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Command) GetUser() string {
	if m != nil {
		return m.User
	}
	return ""
}

func (m *Command) GetCommandSpecifics() *any.Any {
	if m != nil {
		return m.CommandSpecifics
	}
	return nil
}

type Empty struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Empty) Reset()         { *m = Empty{} }
func (m *Empty) String() string { return proto.CompactTextString(m) }
func (*Empty) ProtoMessage()    {}
func (*Empty) Descriptor() ([]byte, []int) {
	return fileDescriptor_a2bc67ef66fabb2c, []int{5}
}

func (m *Empty) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Empty.Unmarshal(m, b)
}
func (m *Empty) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Empty.Marshal(b, m, deterministic)
}
func (m *Empty) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Empty.Merge(m, src)
}
func (m *Empty) XXX_Size() int {
	return xxx_messageInfo_Empty.Size(m)
}
func (m *Empty) XXX_DiscardUnknown() {
	xxx_messageInfo_Empty.DiscardUnknown(m)
}

var xxx_messageInfo_Empty proto.InternalMessageInfo

type BusinessCommand struct {
	Snapshot             *Snapshot `protobuf:"bytes,1,opt,name=snapshot,proto3" json:"snapshot,omitempty"`
	Events               *Events   `protobuf:"bytes,2,opt,name=events,proto3" json:"events,omitempty"`
	Command              *Command  `protobuf:"bytes,3,opt,name=command,proto3" json:"command,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *BusinessCommand) Reset()         { *m = BusinessCommand{} }
func (m *BusinessCommand) String() string { return proto.CompactTextString(m) }
func (*BusinessCommand) ProtoMessage()    {}
func (*BusinessCommand) Descriptor() ([]byte, []int) {
	return fileDescriptor_a2bc67ef66fabb2c, []int{6}
}

func (m *BusinessCommand) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_BusinessCommand.Unmarshal(m, b)
}
func (m *BusinessCommand) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_BusinessCommand.Marshal(b, m, deterministic)
}
func (m *BusinessCommand) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BusinessCommand.Merge(m, src)
}
func (m *BusinessCommand) XXX_Size() int {
	return xxx_messageInfo_BusinessCommand.Size(m)
}
func (m *BusinessCommand) XXX_DiscardUnknown() {
	xxx_messageInfo_BusinessCommand.DiscardUnknown(m)
}

var xxx_messageInfo_BusinessCommand proto.InternalMessageInfo

func (m *BusinessCommand) GetSnapshot() *Snapshot {
	if m != nil {
		return m.Snapshot
	}
	return nil
}

func (m *BusinessCommand) GetEvents() *Events {
	if m != nil {
		return m.Events
	}
	return nil
}

func (m *BusinessCommand) GetCommand() *Command {
	if m != nil {
		return m.Command
	}
	return nil
}

type BusinessResponse struct {
	Snapshot             *Snapshot `protobuf:"bytes,1,opt,name=snapshot,proto3" json:"snapshot,omitempty"`
	Events               *Events   `protobuf:"bytes,2,opt,name=events,proto3" json:"events,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *BusinessResponse) Reset()         { *m = BusinessResponse{} }
func (m *BusinessResponse) String() string { return proto.CompactTextString(m) }
func (*BusinessResponse) ProtoMessage()    {}
func (*BusinessResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_a2bc67ef66fabb2c, []int{7}
}

func (m *BusinessResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_BusinessResponse.Unmarshal(m, b)
}
func (m *BusinessResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_BusinessResponse.Marshal(b, m, deterministic)
}
func (m *BusinessResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BusinessResponse.Merge(m, src)
}
func (m *BusinessResponse) XXX_Size() int {
	return xxx_messageInfo_BusinessResponse.Size(m)
}
func (m *BusinessResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_BusinessResponse.DiscardUnknown(m)
}

var xxx_messageInfo_BusinessResponse proto.InternalMessageInfo

func (m *BusinessResponse) GetSnapshot() *Snapshot {
	if m != nil {
		return m.Snapshot
	}
	return nil
}

func (m *BusinessResponse) GetEvents() *Events {
	if m != nil {
		return m.Events
	}
	return nil
}

func init() {
	proto.RegisterType((*Events)(nil), "evented.Events")
	proto.RegisterType((*Event)(nil), "evented.Event")
	proto.RegisterType((*EventSequence)(nil), "evented.EventSequence")
	proto.RegisterType((*Snapshot)(nil), "evented.Snapshot")
	proto.RegisterType((*Command)(nil), "evented.Command")
	proto.RegisterType((*Empty)(nil), "evented.Empty")
	proto.RegisterType((*BusinessCommand)(nil), "evented.BusinessCommand")
	proto.RegisterType((*BusinessResponse)(nil), "evented.BusinessResponse")
}

func init() { proto.RegisterFile("evented.proto", fileDescriptor_a2bc67ef66fabb2c) }

var fileDescriptor_a2bc67ef66fabb2c = []byte{
	// 456 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x94, 0xcf, 0x6f, 0xd3, 0x30,
	0x14, 0xc7, 0x9b, 0x6e, 0x4b, 0xbb, 0xd7, 0xf5, 0x07, 0x16, 0x42, 0x59, 0x4e, 0x93, 0x0f, 0x30,
	0x31, 0x2d, 0x43, 0xe1, 0x82, 0x84, 0xc4, 0x8f, 0xc1, 0x24, 0x0e, 0x1c, 0x90, 0x7b, 0xe3, 0x96,
	0x26, 0x6f, 0xc5, 0xd0, 0xda, 0xa1, 0x2f, 0x45, 0xea, 0x3f, 0xc0, 0x7f, 0xc0, 0xff, 0x8b, 0xea,
	0xd8, 0xd6, 0x92, 0x00, 0xe2, 0xb2, 0x9b, 0xe3, 0xf7, 0xe9, 0xfb, 0x7e, 0xdf, 0xd7, 0x76, 0x61,
	0x8c, 0x3f, 0x50, 0x55, 0x58, 0x24, 0xe5, 0x46, 0x57, 0x9a, 0x0d, 0xec, 0x67, 0x7c, 0xba, 0xd4,
	0x7a, 0xb9, 0xc2, 0x2b, 0xb3, 0xbd, 0xd8, 0xde, 0x5e, 0x65, 0x6a, 0x57, 0x33, 0xfc, 0x19, 0x84,
	0x37, 0x7b, 0x8a, 0xd8, 0x63, 0x08, 0x0d, 0x4f, 0x51, 0x70, 0x76, 0x70, 0x3e, 0x4a, 0x27, 0x89,
	0xeb, 0x66, 0x00, 0x61, 0xab, 0xfc, 0x1b, 0x1c, 0x99, 0x0d, 0x36, 0x81, 0xbe, 0x2c, 0xa2, 0xe0,
	0x2c, 0x38, 0x3f, 0x16, 0x7d, 0x59, 0x30, 0x06, 0x87, 0x5b, 0xc2, 0x4d, 0xd4, 0x37, 0x3b, 0x66,
	0xbd, 0x67, 0x2a, 0x8a, 0x0e, 0x6a, 0xa6, 0x22, 0x96, 0x40, 0xb8, 0xd0, 0x85, 0x44, 0x8a, 0x86,
	0x46, 0xe4, 0x51, 0x53, 0x64, 0x8e, 0xdf, 0xb7, 0xa8, 0x72, 0x14, 0x96, 0xe2, 0x08, 0xe3, 0x46,
	0x81, 0xc5, 0x30, 0x24, 0xbb, 0x36, 0xd2, 0x63, 0xe1, 0xbf, 0xd9, 0x0b, 0x38, 0x31, 0xdd, 0xde,
	0x63, 0x95, 0xc9, 0x15, 0x19, 0x23, 0xa3, 0xf4, 0x61, 0x52, 0x4f, 0x9f, 0xb8, 0xe9, 0x93, 0xb7,
	0x6a, 0x27, 0x1a, 0x24, 0xff, 0x19, 0xc0, 0x70, 0xae, 0xb2, 0x92, 0xbe, 0xe8, 0xee, 0x5c, 0x77,
	0x25, 0xfb, 0x2d, 0xc9, 0xf6, 0x7c, 0xaf, 0x60, 0x4a, 0xb6, 0x8f, 0x73, 0x71, 0xf8, 0x0f, 0x17,
	0x6d, 0x98, 0x6b, 0x18, 0xbc, 0xd3, 0xeb, 0x75, 0xa6, 0x8a, 0xff, 0x8a, 0xf7, 0x0d, 0xcc, 0xf2,
	0x1a, 0x9f, 0x97, 0x98, 0xcb, 0x5b, 0x99, 0xef, 0x83, 0xfd, 0xbb, 0x5e, 0x87, 0xe6, 0x03, 0x38,
	0xba, 0x59, 0x97, 0xd5, 0x8e, 0xff, 0x0a, 0x60, 0x7a, 0xbd, 0x25, 0xa9, 0x90, 0xc8, 0x59, 0xb8,
	0x84, 0xa1, 0x33, 0x68, 0x8c, 0x8c, 0xd2, 0x07, 0xfe, 0xbc, 0x5c, 0x5c, 0xc2, 0x23, 0xec, 0x89,
	0xbf, 0x41, 0x75, 0xf2, 0xd3, 0xe6, 0xe1, 0x92, 0xbb, 0x42, 0xec, 0x29, 0x0c, 0xac, 0x11, 0x13,
	0xdd, 0x28, 0x9d, 0x79, 0xd2, 0x4a, 0x0b, 0x07, 0xf0, 0xaf, 0x30, 0x73, 0xb6, 0x04, 0x52, 0xa9,
	0x15, 0xe1, 0x7d, 0xf9, 0x4a, 0x57, 0x30, 0xb1, 0xfa, 0x1f, 0x32, 0x55, 0xac, 0x70, 0xc3, 0x2e,
	0x21, 0xac, 0x97, 0xac, 0x63, 0x31, 0x6e, 0xb7, 0xe1, 0x3d, 0x76, 0x01, 0xa1, 0xc0, 0x5c, 0x6f,
	0x0a, 0xd6, 0x2e, 0xc6, 0x77, 0x9e, 0x93, 0xc9, 0xbb, 0x97, 0xbe, 0x84, 0x13, 0x53, 0x73, 0x5a,
	0x17, 0x5e, 0xab, 0xf5, 0xf4, 0xfe, 0xa0, 0x94, 0x7e, 0x82, 0xb1, 0x8b, 0xe5, 0xa3, 0x5e, 0xca,
	0x9c, 0xbd, 0xf6, 0xbf, 0x8e, 0x3c, 0xdd, 0x3a, 0xcf, 0xf8, 0xb4, 0x53, 0x71, 0x91, 0xf2, 0xde,
	0xf5, 0xf1, 0x67, 0xf7, 0x7f, 0xb1, 0x08, 0xcd, 0xa5, 0x79, 0xfe, 0x3b, 0x00, 0x00, 0xff, 0xff,
	0xb3, 0x40, 0x8d, 0x6e, 0x50, 0x04, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// CommandHandlerClient is the client API for CommandHandler service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type CommandHandlerClient interface {
	Handle(ctx context.Context, in *Command, opts ...grpc.CallOption) (*Events, error)
	Record(ctx context.Context, in *Events, opts ...grpc.CallOption) (*Empty, error)
}

type commandHandlerClient struct {
	cc *grpc.ClientConn
}

func NewCommandHandlerClient(cc *grpc.ClientConn) CommandHandlerClient {
	return &commandHandlerClient{cc}
}

func (c *commandHandlerClient) Handle(ctx context.Context, in *Command, opts ...grpc.CallOption) (*Events, error) {
	out := new(Events)
	err := c.cc.Invoke(ctx, "/evented.CommandHandler/Handle", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *commandHandlerClient) Record(ctx context.Context, in *Events, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/evented.CommandHandler/Record", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CommandHandlerServer is the server API for CommandHandler service.
type CommandHandlerServer interface {
	Handle(context.Context, *Command) (*Events, error)
	Record(context.Context, *Events) (*Empty, error)
}

// UnimplementedCommandHandlerServer can be embedded to have forward compatible implementations.
type UnimplementedCommandHandlerServer struct {
}

func (*UnimplementedCommandHandlerServer) Handle(ctx context.Context, req *Command) (*Events, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Handle not implemented")
}
func (*UnimplementedCommandHandlerServer) Record(ctx context.Context, req *Events) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Record not implemented")
}

func RegisterCommandHandlerServer(s *grpc.Server, srv CommandHandlerServer) {
	s.RegisterService(&_CommandHandler_serviceDesc, srv)
}

func _CommandHandler_Handle_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Command)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommandHandlerServer).Handle(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/evented.CommandHandler/Handle",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommandHandlerServer).Handle(ctx, req.(*Command))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommandHandler_Record_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Events)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommandHandlerServer).Record(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/evented.CommandHandler/Record",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommandHandlerServer).Record(ctx, req.(*Events))
	}
	return interceptor(ctx, in, info, handler)
}

var _CommandHandler_serviceDesc = grpc.ServiceDesc{
	ServiceName: "evented.CommandHandler",
	HandlerType: (*CommandHandlerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Handle",
			Handler:    _CommandHandler_Handle_Handler,
		},
		{
			MethodName: "Record",
			Handler:    _CommandHandler_Record_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "evented.proto",
}

// EventHandlerClient is the client API for EventHandler service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type EventHandlerClient interface {
	Handle(ctx context.Context, in *Event, opts ...grpc.CallOption) (*Events, error)
}

type eventHandlerClient struct {
	cc *grpc.ClientConn
}

func NewEventHandlerClient(cc *grpc.ClientConn) EventHandlerClient {
	return &eventHandlerClient{cc}
}

func (c *eventHandlerClient) Handle(ctx context.Context, in *Event, opts ...grpc.CallOption) (*Events, error) {
	out := new(Events)
	err := c.cc.Invoke(ctx, "/evented.EventHandler/Handle", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// EventHandlerServer is the server API for EventHandler service.
type EventHandlerServer interface {
	Handle(context.Context, *Event) (*Events, error)
}

// UnimplementedEventHandlerServer can be embedded to have forward compatible implementations.
type UnimplementedEventHandlerServer struct {
}

func (*UnimplementedEventHandlerServer) Handle(ctx context.Context, req *Event) (*Events, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Handle not implemented")
}

func RegisterEventHandlerServer(s *grpc.Server, srv EventHandlerServer) {
	s.RegisterService(&_EventHandler_serviceDesc, srv)
}

func _EventHandler_Handle_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Event)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EventHandlerServer).Handle(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/evented.EventHandler/Handle",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EventHandlerServer).Handle(ctx, req.(*Event))
	}
	return interceptor(ctx, in, info, handler)
}

var _EventHandler_serviceDesc = grpc.ServiceDesc{
	ServiceName: "evented.EventHandler",
	HandlerType: (*EventHandlerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Handle",
			Handler:    _EventHandler_Handle_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "evented.proto",
}

// BusinessLogicClient is the client API for BusinessLogic service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type BusinessLogicClient interface {
	Handle(ctx context.Context, in *BusinessCommand, opts ...grpc.CallOption) (*BusinessResponse, error)
}

type businessLogicClient struct {
	cc *grpc.ClientConn
}

func NewBusinessLogicClient(cc *grpc.ClientConn) BusinessLogicClient {
	return &businessLogicClient{cc}
}

func (c *businessLogicClient) Handle(ctx context.Context, in *BusinessCommand, opts ...grpc.CallOption) (*BusinessResponse, error) {
	out := new(BusinessResponse)
	err := c.cc.Invoke(ctx, "/evented.BusinessLogic/Handle", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// BusinessLogicServer is the server API for BusinessLogic service.
type BusinessLogicServer interface {
	Handle(context.Context, *BusinessCommand) (*BusinessResponse, error)
}

// UnimplementedBusinessLogicServer can be embedded to have forward compatible implementations.
type UnimplementedBusinessLogicServer struct {
}

func (*UnimplementedBusinessLogicServer) Handle(ctx context.Context, req *BusinessCommand) (*BusinessResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Handle not implemented")
}

func RegisterBusinessLogicServer(s *grpc.Server, srv BusinessLogicServer) {
	s.RegisterService(&_BusinessLogic_serviceDesc, srv)
}

func _BusinessLogic_Handle_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BusinessCommand)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BusinessLogicServer).Handle(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/evented.BusinessLogic/Handle",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BusinessLogicServer).Handle(ctx, req.(*BusinessCommand))
	}
	return interceptor(ctx, in, info, handler)
}

var _BusinessLogic_serviceDesc = grpc.ServiceDesc{
	ServiceName: "evented.BusinessLogic",
	HandlerType: (*BusinessLogicServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Handle",
			Handler:    _BusinessLogic_Handle_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "evented.proto",
}
